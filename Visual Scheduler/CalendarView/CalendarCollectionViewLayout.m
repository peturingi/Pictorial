#import "CalendarCollectionViewLayout.h"

#define CELL_KEY    @"ImageCell"
#define HEADER_KEY  @"DayOfWeekColour"

static const NSInteger INSET_TOP    = 2;
static const NSInteger INSET_LEFT   = 15;
static const NSInteger INSET_RIGHT  = 15;
static const NSInteger INSET_BOTTOM = 2;
static const NSUInteger HEADER_HEIGHT = 20;

@implementation CalendarCollectionViewLayout

- (id)init {
    self = [super init];
    if (self) {
        self.insets = UIEdgeInsetsMake(INSET_TOP, INSET_LEFT, INSET_BOTTOM, INSET_RIGHT);
        _viewMode = Week;
        
    }
    return self;
}

#pragma mark - UICollectionViewLayout Process
/*
 During the layout process, the collection view calls specific methods of this layout object.
 The methods calculate the position of items and provide the collection view with the primary information it needs.
 There are three primary methods which are always called in the same three step order.
 */

#pragma mark Step 1 - Initial Calculations
/*
 Performs up-front calculations needed to provide layout information (such as the position of cells and views).
 This information is used by the collection view in order to determine its scoll view size.
 After calling this method, the layout must have enouth information to calculate the collection view's content size.
 */

- (void)prepareLayout {
    NSDictionary *cellInformation = [self cellAttributes];
    NSDictionary *headerInformation = [self headerAttributes];
    self.layoutInformation = @{CELL_KEY     : cellInformation,
                               HEADER_KEY   : headerInformation};
}

#pragma mark Cell Layout

- (NSDictionary *)cellAttributes {
    @throw [NSException exceptionWithName:@"Not implemented." reason:@"This method must be implemented by a subclass." userInfo:nil];
    return nil;
}

- (NSInteger)sectionRepresentingToday {
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"c"];
    NSString *dayOfWeek = [formatter stringFromDate:[NSDate date]];
    NSInteger section = [dayOfWeek integerValue] - 1;
    return section;
}

- (CGRect)frameForItemAtIndexPath:(NSIndexPath *)indexPath {
    CGRect rect;
    rect.origin = [self originForItemAtIndexPath:indexPath];
    rect.size = [self sizeOfItems];
    return rect;
}

- (CGPoint)originForItemAtIndexPath:(NSIndexPath *)indexPath {
    @throw [NSException exceptionWithName:@"Abstract method." reason:@"This method should be overwritten by a subclass" userInfo:nil];
    return CGPointMake(0,0);
}

- (CGSize)sizeOfItems {
    @throw [NSException exceptionWithName:@"Abstract method." reason:@"This method should be overwritten by a subclass" userInfo:nil];
}

#pragma mark Header Layout

- (NSDictionary *)headerAttributes {
    @throw [NSException exceptionWithName:@"Abstract method." reason:@"This method should be overwritten by a subclass" userInfo:nil];
    return nil;
}

- (CGRect)frameForHeaderOfSection:(NSUInteger)section {
    CGRect rect;
    rect.origin = [self originForHeaderOfSection:section];
    rect.size = [self headerSize];
    return rect;
}

- (CGPoint)originForHeaderOfSection:(NSUInteger)section {
    @throw [NSException exceptionWithName:@"Abstract Method." reason:@"This method should be overwritten by a subclass." userInfo:nil];
    return CGPointMake(0, 0);
}


- (CGSize)headerSize {
    CGFloat width = [self columnWidth];
    CGFloat height = HEADER_HEIGHT;
    return CGSizeMake(width, height);
}

#pragma mark Step 2 - CollectionView Size and Grid configuration

/* 
 Return the overall size of the entire content, based on initial calculations.
 */

- (CGSize)collectionViewContentSize {
    CGFloat contentWidth = self.collectionView.bounds.size.width;
    CGFloat contentHeight = self.maxNumRows * [self rowHeight] + ([self headerSize].height + self.insets.top + self.insets.bottom);
    return CGSizeMake(contentWidth, contentHeight);
}

- (CGFloat)rowHeight {
    return [self sizeOfItems].height + self.insets.top + self.insets.bottom;
}

- (CGFloat)columnWidth {
    return self.collectionView.bounds.size.width / self.collectionView.numberOfSections;
}

#pragma mark Step 3
/*
 Provide layout attributes for every cell and every supplementary or decoration view that
 intersects the area currently shown (sometimes not shown!) by the collectionview's scrollview.
 
 The implementation of this step is a known algorithm described by Apple as:
 1. Iterate over the data generated by prepareLayout, to either access cached attributes or create new ones as needed.
 2. Check the frame of each item to see whether it intersects the rectangle passsed to the layoutAttributesForElementsInRect.
 3. For each intersecting item, add a corresponding UICollectionViewLayoutAttributeObject to the array to be returned.
 4. Return the array of layout attributes to the collection view.
*/

- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect {
    NSMutableArray *results = [NSMutableArray arrayWithCapacity:self.layoutInformation.count];
    
    for (NSString *key in self.layoutInformation) {
        NSDictionary *attributes = [self.layoutInformation objectForKey:key];
        NSArray *intersectingAttributes;
        if ([key isEqualToString:CELL_KEY]) {
            intersectingAttributes = [self attributesIn:attributes intersecting:rect];
            [results addObjectsFromArray:intersectingAttributes];
        }
        if ([key isEqualToString:HEADER_KEY]) {
            NSDictionary *headerAttributes = [self headerAttributes];
            for (NSIndexPath *key in headerAttributes) {
                [results addObject:[headerAttributes objectForKey:key]];
            }
        }
    }
    return results;
}

- (NSArray *)attributesIn:(NSDictionary *)dictionary intersecting:(CGRect)rect {
    NSMutableArray *results = [NSMutableArray arrayWithCapacity:dictionary.count];
    for (NSIndexPath *key in dictionary) {
        UICollectionViewLayoutAttributes *attributes = [dictionary objectForKey:key];
        if (CGRectIntersectsRect(rect, attributes.frame)) {
            [results addObject:attributes];
        }
    }
    return results;
}

#pragma mark -

/* Collectionview asks if we want to invalidate (and recompute) the layout on scrolling and orientation change. */
- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds {
    return YES;
}

/*
 Called by the collection view when it needs information about cells that might currently not be visible.
 Required for animation.
 */
- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath {
    NSDictionary *cellInformation = [self.layoutInformation objectForKey:CELL_KEY];
    UICollectionViewLayoutAttributes *attributes = [cellInformation objectForKey:indexPath];
    
    /* hack? put unkonwn indexpaths in top left corner. */
    if (attributes == nil) {
        attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
    }
    
    return attributes;
}

/*
 Called by the collection view when it needs information about cells that might currently not be visible.
 */
- (UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath {
    UICollectionViewLayoutAttributes *attributes = nil;
    if ([kind isEqualToString:HEADER_KEY]) {
        NSDictionary *headerAttributes = [self.layoutInformation objectForKey:HEADER_KEY];
        attributes = [headerAttributes objectForKey:indexPath];
    }
    return attributes;
}

#pragma mark - Scrolling

- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity
{
    CGFloat offsetAdjustment = MAXFLOAT;
    CGFloat verticalOffset = proposedContentOffset.y;
    
    CGRect targetRect = CGRectMake(0, proposedContentOffset.y, self.collectionView.bounds.size.width, self.collectionView.bounds.size.height);
    
    NSArray *array = [self layoutAttributesForElementsInRect:targetRect];
    
    for (UICollectionViewLayoutAttributes *layoutAttributes in array) {
        CGFloat itemOffset = layoutAttributes.frame.origin.y;
        if (ABS(itemOffset - verticalOffset) < ABS(offsetAdjustment)) {
            offsetAdjustment = itemOffset - verticalOffset;
        }
    }
    CGPoint offset = CGPointMake(proposedContentOffset.x, proposedContentOffset.y + offsetAdjustment);
    offset.y -= [self headerSize].height;
    return offset;
}

@end